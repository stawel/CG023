/*
  NRF24_Sniff - An Arduino sketch to promiscuous capture all wireless
                traffic generated by Nordic Semi. NRF24L01+ modules.

  Created by Ivo Pullens, Emmission, 2014 -- www.emmission.nl
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/   
 
#include <Arduino.h>
#include <SPI.h>
#include <CircularBuffer.h>
#include <RF24.h>
#include <RF24_config.h>


// Hardware configuration
#define RF_CE_PIN                      (9)
#define RF_CS_PIN                      (10)
#define RF_IRQ_PIN                     (2)
#define RF_IRQ                         (RF_IRQ_PIN-2)                                           // Usually the interrupt = pin -2 (on uno/nano anyway)


#define RF_MAX_ADDR_WIDTH              (5)                                                      // Maximum address width, in bytes. MySensors use 5 bytes for addressing, where lowest byte is for node addressing.
#define MAX_RF_PAYLOAD_SIZE            (16)
#define SER_BAUDRATE                   (115200)
#define PACKET_BUFFER_SIZE             (30)                                                     // Maximum number of packets that can be buffered between reception by NRF and transmission over serial port.
#define PIPE                           (0)                                                      // Pipe number to use for listening


// Startup defaults until user reconfigures it
#define DEFAULT_RF_CHANNEL             5
#define DEFAULT_RF_ADDR_WIDTH          5
#define DEFAULT_RADIO_ID               {0xcc, 0xcc, 0xcc, 0xcc, 0xcc}



// If BINARY_OUTPUT is defined, this sketch will output in hex format to the PC.
// If undefined it will output text output for development.
#define BINARY_OUTPUT

#include "NRF24_sniff_types.h"
uint8_t xn297_addr_len = DEFAULT_RF_ADDR_WIDTH;

static const uint8_t xn297_scramble[] = {
  0xe3, 0xb1, 0x4b, 0xea, 0x85, 0xbc, 0xe5, 0x66,
  0x0d, 0xae, 0x8c, 0x88, 0x12, 0x69, 0xee, 0x1f,
  0xc7, 0x62, 0x97, 0xd5, 0x0b, 0x79, 0xca, 0xcc,
  0x1b, 0x5d, 0x19, 0x10, 0x24, 0xd3, 0xdc, 0x3f,
  0x8e, 0xc5, 0x2f};

static uint8_t bit_reverse(uint8_t b_in)
{
    uint8_t b_out = 0;
    for (int i = 0; i < 8; ++i) {
        b_out = (b_out << 1) | (b_in & 1);
        b_in >>= 1;
    }
    return b_out;
}

void scramble_data(uint8_t *p, int len)
{
  for(uint8_t i=0; i<len; i++) {
      p[i] = bit_reverse(p[i])^bit_reverse(xn297_scramble[i+xn297_addr_len]);
  }
}
                      

#ifndef BINARY_OUTPUT
int my_putc( char c, FILE *t )
{
  Serial.write( c );
}
#endif

// Set up nRF24L01 radio on SPI bus plus CE/CS pins
static RF24 radio(RF_CE_PIN, RF_CS_PIN);

static NRF24_packet_t bufferData[PACKET_BUFFER_SIZE]; 
static CircularBuffer<NRF24_packet_t> packetBuffer(bufferData, sizeof(bufferData)/sizeof(bufferData[0]));
static Serial_header_t serialHdr;

uint8_t oldbuf[256];
int pos = 0;
int size = 0;

void dumpData(uint8_t* p, int len)
{
  scramble_data(p, len);
#ifndef BINARY_OUTPUT
  while (len--) { printf("%02x", *p++); }
  Serial.print(' ');
#else

  //Serial.print('|');
  //for(int i=0;i<len;i++) { Serial.print((int)p[i]); }
  //Serial.println();

  size -= pos;
  for(int i = 0; i<size;i++) {
    oldbuf[i]=oldbuf[i+pos];
  }
  pos = 0;

  for(int i = 0; i<len;i++) {
    oldbuf[size++]=p[i];
  }


  for(;pos<size;pos++) {
    if(oldbuf[pos] > 128) {
      if(size-pos < 5) break;
      char c = oldbuf[pos]-128;
      if(c == 'i') {
        int32_t data;
        uint8_t * d_ptr = (uint8_t *)&data;
        pos++;
        d_ptr[0]=oldbuf[pos++];
        d_ptr[1]=oldbuf[pos++];
        d_ptr[2]=oldbuf[pos++];
        d_ptr[3]=oldbuf[pos];
        Serial.print(data);
      } else if (c == 'f') {
        float data;
        uint8_t * d_ptr = (uint8_t *)&data;
        pos++;
        d_ptr[0]=oldbuf[pos++];
        d_ptr[1]=oldbuf[pos++];
        d_ptr[2]=oldbuf[pos++];
        d_ptr[3]=oldbuf[pos];
        Serial.print(data);
      } else if (c == '8') {
        pos++;
        Serial.print(((uint8_t)oldbuf[pos]));
      } else if (c == 'F') {
        Serial.println();
        Serial.println("[BUFFER FULL]");
      }
    } else if (oldbuf[pos] == '\n') {
        Serial.println();
    } else {
      if(oldbuf[pos] != 0)
        Serial.write(oldbuf[pos]);
    }
  }
#endif
}

void handleNrfIrq()
{
  static uint8_t lostPacketCount = 0;
  // Loop until RX buffer(s) contain no more packets.
  while (radio.available())
  {
    if (!packetBuffer.full())
    {
      NRF24_packet_t* p = packetBuffer.getFront();
      p->timestamp = micros();  // Micros does not increase in interrupt, but it can be used.
      p->packetsLost = lostPacketCount;
      uint8_t packetLen = radio.getPayloadSize();
      if (packetLen > MAX_RF_PAYLOAD_SIZE)
        packetLen = MAX_RF_PAYLOAD_SIZE;
  
      radio.read( p->packet, packetLen );
      
      packetBuffer.pushFront(p);
    }
  }
}  

void activateConf( void )
{
  radio.setChannel(DEFAULT_RF_CHANNEL);

  radio.setDataRate(RF24_1MBPS);
  //radio.setDataRate(RF24_2MBPS);

  radio.setCRCLength(RF24_CRC_DISABLED);
  radio.setPayloadSize(MAX_RF_PAYLOAD_SIZE);

  radio.setAddressWidth(xn297_addr_len);
  uint8_t  binding_adr_rf[5]=DEFAULT_RADIO_ID;

  for (int i = 0; i < xn297_addr_len; ++i) {
    binding_adr_rf[i] = binding_adr_rf[i] ^ xn297_scramble[xn297_addr_len-i-1];
  }

  uint64_t * adr = (uint64_t*)&binding_adr_rf;
  radio.openReadingPipe( 0, *adr);


  radio.startListening();

#ifndef BINARY_OUTPUT  
  radio.printDetails();

  Serial.println("");
  Serial.println("Listening...");
#endif
}


void setup(void)
{

  Serial.begin(SER_BAUDRATE);

  Serial.println("-- start --");
#ifndef BINARY_OUTPUT
  fdevopen( &my_putc, 0);
  Serial.println("-- RF24 Sniff --");
#endif

  radio.begin();

  // Disable shockburst
  radio.setAutoAck(false);
  radio.setRetries(0,0);

  // Configure nRF IRQ input
  pinMode(RF_IRQ_PIN, INPUT);

  activateConf();
}



void loop(void)
{
  handleNrfIrq();
  while (!packetBuffer.empty())
  {
    // One or more records present
    NRF24_packet_t* p = packetBuffer.getBack();
    dumpData(p->packet, radio.getPayloadSize());
    //Serial.println();
    // Remove record as we're done with it.
    packetBuffer.popBack();
  }
}
// vim:cin:ai:sts=2 sw=2 ft=cpp1
